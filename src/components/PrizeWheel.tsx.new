import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle } from 'react';

export interface PrizeWheelHandle {
  spinWheel: () => void;
  resetSpinFlag: () => void;
}

interface PrizeWheelProps {
  segments: string[];
  segColors: string[];
  onFinished?: (winner: string) => void;
  primaryColor?: string;
  contrastColor?: string;
  buttonText?: string;
  size?: number;
  upDuration?: number;
  downDuration?: number;
  fontFamily?: string;
  winningSegment?: string;
  zIndex?: number;
  autoSpin?: boolean;
}

const PrizeWheel = forwardRef<PrizeWheelHandle, PrizeWheelProps>(({
  segments,
  segColors,
  onFinished = () => {},
  primaryColor = '#333',
  contrastColor = '#fff',
  buttonText = 'SPIN',
  size = 290,
  upDuration = 100,
  downDuration = 1000,
  fontFamily = 'Arial',
  winningSegment,
  zIndex = 9999,
  autoSpin = false
}, ref) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isSpinning, setIsSpinning] = useState(false);
  const [winner, setWinner] = useState<string | null>(null);
  const [rotation, setRotation] = useState(0);
  const hasSpunRef = useRef(false);
  
  // Canvas dimensions
  const canvasSize = size;
  const centerX = canvasSize / 2;
  const centerY = canvasSize / 2;
  const radius = (canvasSize / 2) * 0.9; // 90% of half the canvas size
  
  // Expose the spinWheel function to parent components
  useImperativeHandle(ref, () => ({
    spinWheel: () => {
      if (!isSpinning) spinWheel();
    },
    resetSpinFlag: () => {
      console.log('Resetting spin flag');
      hasSpunRef.current = false;
    }
  }));
  
  // Draw the wheel whenever rotation changes
  useEffect(() => {
    drawWheel();
  }, [rotation, segments, segColors]);
  
  // Single auto-spin effect with flag to prevent multiple spins
  useEffect(() => {
    // Only spin if autoSpin is true, not currently spinning, and hasn't spun before
    if (autoSpin && !isSpinning && !hasSpunRef.current) {
      console.log('Auto-spinning wheel (first time only)');
      hasSpunRef.current = true; // Mark as spun to prevent future spins
      
      const spinTimeout = setTimeout(() => {
        spinWheel();
      }, 100); // Short delay to ensure wheel is visible
      
      return () => clearTimeout(spinTimeout);
    }
  }, [autoSpin, isSpinning]);
  
  // Initialize canvas and draw wheel
  useEffect(() => {
    console.log('Initializing wheel canvas');
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Set canvas dimensions
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // Force immediate draw
    drawWheel();
  }, []);
  
  const drawWheel = () => {
    console.log('Drawing wheel...');
    const canvas = canvasRef.current;
    if (!canvas) {
      console.error('Canvas ref is null');
      return;
    }
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Could not get 2D context');
      return;
    }
    
    console.log(`Canvas size: ${canvasSize}x${canvasSize}, Radius: ${radius}`);
    console.log(`Drawing ${segments.length} segments with colors:`, segColors);
    
    // Clear canvas
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    
    // Draw wheel segments
    const segmentAngle = (2 * Math.PI) / segments.length;
    
    for (let i = 0; i < segments.length; i++) {
      // Start angle
      const startAngle = i * segmentAngle + rotation;
      // End angle
      const endAngle = (i + 1) * segmentAngle + rotation;
      
      // Draw segment
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.closePath();
      
      // Fill segment
      ctx.fillStyle = segColors[i % segColors.length];
      ctx.fill();
      
      // Add segment border
      ctx.lineWidth = 1;
      ctx.strokeStyle = contrastColor;
      ctx.stroke();
      
      // Add text
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(startAngle + segmentAngle / 2);
      
      // Draw segment text
      ctx.fillStyle = contrastColor;
      const fontSize = Math.max(10, radius / 12); // Adjust font size based on radius
      ctx.font = `bold ${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Position text along the radius at 60% from center for better positioning
      const textRadius = radius * 0.6;
      ctx.translate(textRadius, 0);
      
      // Rotate text to be perpendicular to the radius
      ctx.rotate(Math.PI / 2);
      
      // Shorten text if needed
      let segmentText = segments[i];
      if (segmentText.length > 6) {
        // For longer text, use smaller font or abbreviate
        ctx.font = `bold ${fontSize * 0.75}px ${fontFamily}`;
        if (segmentText.length > 8) {
          segmentText = segmentText.substring(0, 6) + '..';
        }
      }
      
      // Draw the text
      ctx.fillText(segmentText, 0, 0);
      ctx.restore();
    }
    
    // Draw center circle
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius * 0.15, 0, 2 * Math.PI);
    ctx.fillStyle = primaryColor;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = contrastColor;
    ctx.stroke();
  };
  
  const spinWheel = () => {
    if (isSpinning) return;
    
    console.log('Spinning wheel...');
    setIsSpinning(true);
    setWinner(null);
    
    // Calculate the segment angle
    const segmentAngle = (2 * Math.PI) / segments.length;
    
    // Calculate spin parameters
    let spinDegrees;
    
    // If a winning segment is specified, calculate the exact rotation to land on it
    if (winningSegment && segments.includes(winningSegment)) {
      const targetIndex = segments.indexOf(winningSegment);
      // Calculate the rotation needed to land on the target segment
      // We add 5 full rotations for dramatic effect
      spinDegrees = 5 * 2 * Math.PI + (segments.length - targetIndex - 0.5) * segmentAngle;
      console.log(`Targeting segment: ${winningSegment} at index ${targetIndex}`);
    } else {
      // Random spin if no winning segment is specified
      spinDegrees = 5 * 2 * Math.PI + (Math.random() * 2 * Math.PI); // 5 full rotations + random
    }
    
    // Animate the spin
    let currentRotation = rotation;
    const startTime = Date.now();
    const totalDuration = upDuration + downDuration;
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      let progress;
      
      if (elapsed < totalDuration) {
        if (elapsed < upDuration) {
          // Acceleration phase
          progress = elapsed / upDuration;
          progress = progress * progress; // Quadratic easing
        } else {
          // Deceleration phase
          progress = (elapsed - upDuration) / downDuration;
          progress = 1 - (1 - progress) * (1 - progress); // Inverse quadratic easing
          progress = 0.5 + (progress * 0.5); // Map to 0.5-1.0 range
        }
        
        const newRotation = currentRotation + (spinDegrees * progress);
        setRotation(newRotation);
        
        requestAnimationFrame(animate);
      } else {
        // Spin complete
        const finalRotation = currentRotation + spinDegrees;
        setRotation(finalRotation);
        
        // Determine the winning segment
        const normalizedRotation = finalRotation % (2 * Math.PI);
        const segmentIndex = Math.floor(segments.length - (normalizedRotation / segmentAngle) % segments.length) % segments.length;
        const winningSegmentText = segments[segmentIndex];
        
        setIsSpinning(false);
        setWinner(winningSegmentText);
        
        // Call onFinished after a slight delay to ensure the wheel has stopped visually
        setTimeout(() => {
          onFinished(winningSegmentText);
        }, 500);
      }
    };
    
    requestAnimationFrame(animate);
  };
  
  return (
    <div className="relative" style={{ width: `${size}px`, height: `${size}px`, zIndex }}>
      {/* Main canvas wheel */}
      <canvas
        ref={canvasRef}
        width={canvasSize}
        height={canvasSize}
        className="mx-auto block"
        style={{
          borderRadius: '50%',
          boxShadow: '0 0 10px rgba(0,0,0,0.5)'
        }}
      />
      
      {/* Spin button */}
      {buttonText && !isSpinning && (
        <button
          onClick={spinWheel}
          disabled={isSpinning}
          className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow-lg disabled:opacity-50 disabled:cursor-not-allowed z-10"
        >
          {buttonText}
        </button>
      )}
      
      {/* Status text */}
      {isSpinning && (
        <div className="absolute w-full text-center bottom-[-30px] text-white font-bold text-lg">
          Spinning for your prize...
        </div>
      )}
      
      {winner && !isSpinning && (
        <div className="absolute w-full text-center bottom-[-30px] text-white font-bold text-lg">
          You won: {winner}!
        </div>
      )}
    </div>
  );
});

PrizeWheel.displayName = 'PrizeWheel';

export default PrizeWheel;
